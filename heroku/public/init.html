<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<meta name="generator" content="Slide Show (S9); see slideshow.rubyforge.org">
<meta name="author" content="Andrea Brancaleoni">

<title>Sistemi di Avvio</title>

<!-- Don't alter this, CSSS needs it to work -->
<link href="slideshow.css" rel="stylesheet" />

<!-- Theme-specific styles go here (themes can be reused in multiple talks) -->
<link href="theme.css" rel="stylesheet" />

<!-- Talk-specific styles go here -->
<!-- GB: changed fixed name (talk.css) to variable -->
<link href="init.css" rel="stylesheet" />
	
</head>
<!-- GB: todo: add duration header/property -->
<body data-duration="45">

<header id="intro" class="slide">
	<h1>Sistemi di Avvio</h1>
	<p class="attribution">By Andrea Brancaleoni</p>
</header>

	<section class="slide" id="navigation">
		<h2>CSSS Navigation</h2>
		<p>Only through keyboard for now :(</p>
		<ul>
			<li>→ or ↓ to advance to the next slide or incrementally displayed item</li>
			<li>← or ↑ to go to the previous slide or incrementally displayed item</li>
			<li>Ctrl* + → or Ctrl* + ↓ to jump to the next slide</li>
			<li>Ctrl* + ← or Ctrl* + ↑ to jump to the previous slide</li>
			<li>Home to go to the first slide, End to go to the last</li>
			<li>Ctrl* + G to jump to an arbitrary slide (by slide number or identifier)</li>
		</ul>
		<p>* Ctrl or Shift actually. Only Shift works in Opera.</p>
	</section>

	<section class="slide">
		<h2>CSSS Navigation Cont.</h2>
		
		<p>Thumbnail view</p>
		<ul>
		  <li>Press Ctrl+H (or Shift+H if you're in Opera) now.</li>
		  <li>Press Ctrl+Shift+H to see all slides (warning: can be slow!)</li>
		</ul>
		
		<p>Presenter view</p>
		<ul>
		  <li>This slide has presenter notes. They are only visible in presenter view (Ctrl+P or Shift+P).</li>
		</ul>
		<p class="presenter-notes">Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>		
		
	</section>

<!-- note: assumes no header (breaking slides w/ SLIDE directive) -->

  <section class="slide">
    <!-- === begin markdown block =====================================================

      generated by markdown 1.0.0 on Ruby 1.9.3 (2013-02-22) [x86_64-linux]
                on 2013-04-09 19:00:32 +0200 with Markdown engine kramdown (1.0.1)
                  using options { !to be done! }
  -->

<!-- _S9SLIDE_ -->
<h2 id="cos-un-sistema-di-avvio">Cos’è un Sistema di Avvio</h2>

<p>Il compito di avviare e riavviare il computer è svolto da uno speciale componente chiamato <em>init</em>. <em>Init</em> è responsabile di terminare l’avvio dopo che il kernel è stato caricato.</p>

<p><em>Init</em> Avvia altri programmi detti Demoni. Ad esempio avvia il server grafico in un sistema Desktop o un server SQL o HTTP in sistemi Server.</p>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="affidabilit">Affidabilità</h2>

<p>L’affidabilità e la sicurezza è molto importante per un demone di init dato che:</p>

<ul>
  <li>Gira in modalità super utente.</li>
  <li>É responsabile di controllare servizi di sistema critici.</li>
  <li>Se init muore per qualsiasi ragione, il kernel va in panic.</li>
</ul>

<p>Il sistema di init non deve essere compromesso, dato che se fallisce, il kernel va in panic. Dunque, tutte le funzionalità che non sono considerate “core” devono essere tolte e messe negli altri demoni.</p>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="recall-demone">Recall: Demone</h2>

<p>“I demoni sono personaggi della mitologia greca, alcuni dei quali eseguivano compiti di cui gli dei non potevano occuparsi” - Wikipedia</p>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="linea-evolutiva">Linea Evolutiva</h2>

<ul>
  <li>Sistemi di avvio sequenziali: sistemi di avvio in cui ogni demone è avviato in sequenza.
appartengono a questa famiglia tutti i primi sistemi di avvio dove o non si era in possesso di architetture multicore/manycore o non era necessario accendere/spegnere la macchina in continuazione ma era più importante l’uptime. (EG. System-V init, BSD-Style init)</li>
  <li>Sistemi di avvio gerarchici: evoluzione dei sistemi di avvio sequenziali forniscono parallelismo all’avvio inizializzando contemporaneamente servizi tra loro indipendenti. (EG: OpenRC, InitNG)</li>
  <li>Sistemi di avvio Startless/Event Based: spesso forniscono funzionalità simili ai sistemi di avvio gerarchico, tuttavia il loro funzionamento interno è diverso. (EG: LaunchD, Upstart, SystemD)</li>
</ul>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="linea-evolutive">Linea Evolutive</h2>

<p><img src="timeline.png" alt="Linee Evolutive" /></p>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="system-v-init">System-V init</h2>

<p>System-V init è lo standard per quanto riguarda i sistemi di avvio su Linux, comprese le alternative completamente compatibili (e ovviamente su System-V). In questo senso è anche il sistema di avvio più diffuso. Il suo ruolo principlae è di creare processi da uno script in /etc/inittab.</p>

<p>SYSVINIT, L’implementazione più famosa, contiene anche altri programmi che gestiscono l’avvio/il riavvio/lo spegnimento del computer. Ad esempio contiene:
- reboot
- shutdown
- killall
- poweroff
- tellinit
- sulogin
- wall
- etc.</p>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="launchd">LaunchD</h2>

<p>LaunchD è un framework open-source per gestire avvio e spegimento di altri demoni, applicazioni, processi e script. 
È stato scritto da Dave Zarzycki alla Apple, dove è stato introdotto, per la prima volta in Mac OS X Tiger, 
era licenziato sotto Apple Public License ma, per facilitarne l’adozione, la licenza fu cambiata con la Apache.</p>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="caratteristiche-di-launchd">Caratteristiche di LaunchD</h2>
<p>LaunchD è essenzialmente un sostituto per:</p>

<ul>
  <li>init</li>
  <li>rc</li>
  <li>init.d script</li>
  <li>rc.d script</li>
  <li>SystemStarter (Mac OS X)</li>
  <li>inetd / xinetd</li>
  <li>crond / atd</li>
  <li>watchdogd</li>
</ul>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="upstart">Upstart</h2>

<p>Upstart è un sostituto <em>event-based</em> del demone di init. Fu originariamente sviluppato per Ubuntu, ma col tempo è stato adottato
da tutte le principali distribuzioni Desktop.</p>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="caratteristiche-di-upstart">Caratteristiche di Upstart</h2>

<ul>
  <li>I Task e i Servizi sono avviati e fermati tramite eventi</li>
  <li>Gli eventi vengono generati mentre i servizi vengono avviati e fermati</li>
  <li>Gli eventi possono essere ascoltati da qualsiasi altro processo nel sistema</li>
  <li>I servizi possono essere riavviati se muoiono inaspettatamente</li>
  <li>La comunicazione con il demone di init avviene attraverso D-BUS</li>
  <li>Servizi Utente, che gli utenti stessi possono avviare e stoppare</li>
</ul>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="systemd">SystemD</h2>

<p>SystemD è un service manager per Linux, compatibile con SysV e gli init scripts LSB. SystemD fornisce parallelizzazione aggressiva, usa Socket
e D-Bus per avviare i servizi, offre avvio on-demand, tiene traccia dei processi attivi con i control groups (CGROUP), mantiene i punti di mount e
automount e e implementa un elaborata logica transazionale dependency based.</p>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="recall-the-commandment">Recall: The Commandment</h2>

<p>Non avrai altro Dio al di fuori di me</p>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="caratteristiche-di-systemd">Caratteristiche di SystemD</h2>

<ul>
  <li>Parallelizzazione estrema</li>
  <li>Attivazione Socket Based (inetd)</li>
  <li>Bus Based Activation tramite D-BUS</li>
  <li>Caricamento On-Demand, anche di File-System (autofs)</li>
  <li>No Shell Scripts</li>
  <li>Monitoraggio attraverso Control Groups</li>
</ul>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="parallelizzazione">Parallelizzazione</h2>

<p><img src="parallelization.png" alt="Parallelization" /></p>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="crash-course-systemvinit">Crash Course: SystemVinit</h2>

<ul>
  <li>Una volta lanciato init, il sistema operativo è formalmente pronto.</li>
  <li>Init ha il compito di generare tutti gli altri processi necessari al sistema. 
Esempio classico di processo generato da init è getty (attiva il terminale e inizia la procedura di accesso).</li>
  <li>Init, per sapere cosa fare, utilizza come proprio file di configurazione /etc/inittab</li>
  <li>/etc/inittab divide i vari programmi da lanciare all’avvio in livelli di esecuzione chiamati “runlevel”.</li>
</ul>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="getty">Getty</h2>

<p><img src="getty.png" alt="Getty" /></p>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="runlevel-e-init">Runlevel e init</h2>

<p>L’avvio dei vari processi del sistema può essere suddiviso in 6 livelli di
funzionamento</p>

<ul>
  <li>Runlevel 0 (speciale): sistema completamente fermo</li>
  <li>Runlevel 1 o S: modalità monoutente (single user mode)</li>
  <li>Runlevel da 2 a 5: modalità multiutente</li>
  <li>
    <p>Runlevel 6: riavvio</p>
  </li>
  <li>/etc/inittab :
    <ol>
      <li>Indica ad init di lanciare e controllare che siano sempre attivi
alcuni processi (ad esempio getty).</li>
      <li>In generale definisce cosa fare per ciascun runlevel.
All’avvio il sistema si porta dal runlevel 0 fino al runlevel di default
(anche questo dichiarato in /etc/inittab come vedremo in seguito)
passando in tutti quelli intermedi. Viceversa allo shutdown.</li>
    </ol>
  </li>
</ul>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="runlevel-in-debian">Runlevel in Debian</h2>

<ul>
  <li>Runlevel 0 è halt</li>
  <li>Runlevel 1 è single-user mode</li>
  <li>Runlevel 2 -&gt; 5 sono multiutente, di default solo il 2 è utilizzato. Gli altri sono a uso dell’utente.</li>
  <li>Runlevel 6 è riavvio</li>
</ul>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="init-forking-order">Init Forking Order</h2>

<p><img src="initfork.png" alt="Init Forking Order" /></p>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="init-startup">Init Startup</h2>

<p><img src="initstart.png" alt="Init Startup" /></p>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="init-stop">Init Stop</h2>

<p><img src="initstop.png" alt="Init Stop" /></p>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="init-script-scaffold">Init Script Scaffold</h2>

<pre><code>#!/bin/sh

case "$1" in
start)
  echo "Starting!"
  ;;
stop)
  echo "Stopping!"
  ;;
restart)
  echo "Restarting!"
  ;;
esac
</code></pre>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="controllare-servizi-manualmente">Controllare servizi manualmente</h2>

<table>
  <tbody>
    <tr>
      <td>Dopo esserci mossi nella directory contente gli script di servizio basterà invocarli con gli argomenti (start</td>
      <td>stop</td>
      <td>restart).</td>
    </tr>
  </tbody>
</table>

<p>In Debian:</p>

<ul>
  <li>
    <p><code>/etc/init.d/service start</code> </p>

    <p><em>avvia il servizio</em></p>
  </li>
  <li>
    <p><code>/etc/init.d/service stop</code> </p>

    <p><em>ferma il servizio</em></p>
  </li>
  <li>
    <p><code>/etc/init.d/service restart</code> </p>

    <p><em>riavvia il servizio</em></p>
  </li>
</ul>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="comando-halt">Comando: halt</h2>
<p><code>halt [options]</code></p>

<p>Spegne il computer. Inserisce una note in /var/log/wtmp; se il sistema è nel runlevel 0 o 6 ferma tutti i processi; altrimenti richiama <strong>shutdonw -h</strong></p>

<h3 id="opzioni">Opzioni</h3>
<p><strong>-d</strong> non scrive in /var/log/wtmp.</p>

<p><strong>-f</strong> Chiama <strong>halt</strong> anche se <strong>shutdown -nf</strong> sarebbe stato chiamato (i.e. chiama <strong>halt</strong> anche se non si è nel runlevel 0 o 6).</p>

<p><strong>-h</strong> Mette l’hard disk in stand-by prima di chiamare <strong>halt</strong> o spegnere.</p>

<p><strong>-i</strong> Spegne le interfacce di rete prima dell’<strong>halt</strong>.</p>

<p><strong>-n</strong> Non sincronizza prima di spegnere o riavviare.</p>

<p><strong>-p</strong> Spegne mentre si sta fermando il sistema.</p>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="comando-reboot">Comando: reboot</h2>

<p><code>reboot [options]</code></p>

<p>Chiude i filesystem, spegne il sistema, successivamente riavvia. Poichè questo comando ferma istantaneamente tutti i processi, dovrebbe essere utilizzato solamente in single-user mode. Se il sistema non è nel runlevel 0 o 6, <strong>reboot</strong> richiama <strong>shutdown -r</strong>.</p>

<h3 id="opzioni-1">Opzioni</h3>
<p><strong>-f</strong> Chiama <strong>reboot</strong> anche quando <strong>shutdown</strong> verrebbe invocato.</p>

<p><strong>-i</strong> Spegne tutte le interfacce di rete prima di riavviare.</p>

<p><strong>-n</strong> Non invoca <strong>sync</strong> prima di spegnere.</p>

<p><strong>-w</strong> Non esegue veramente, scrive solamente il log su /var/log/wtmp.</p>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="comando-runlevel">Comando: runlevel</h2>
<p><code>runlevel [utmp]</code></p>

<p>Mostra il runlevel precedente e il corrente come è stato salvato in <em>utmp</em>. La locazione standard di <em>utmp</em> è in <em>/var/run/utmp</em>.</p>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="comando-shutdown">Comando: shutdown</h2>

<p><code>shutdown [options] when [message]</code></p>

<p>Termina tutti i processi. <em>when</em> può essere un momento specifico nel formato <em>ore:minuti</em>, o un numero di minuti da aspettare nel formato <em>+m</em> o <strong>now</strong>. Un messaggioin broadcast viene notificato a tutti gli utenti per deautenticarli. Ai processi viene inviato un <strong>SIGTERM</strong> per permettergli di uscire normalmente. <em>/etc/init</em> viene chiamato per effettuare lo shutdown, che consiste nel portare il sistema al runlevel 0.</p>

<h3 id="opzioni-2">Opzioni</h3>
<p><strong>-a</strong> Quando viene chiamato da <strong>init</strong>, spegne solo se uno degli utente in <em>/shutdown.allow</em> è loggato attualmente.</p>

<p><strong>-c</strong> Annulla un procedimento di spegnimento in corso.</p>

<p><strong>-f</strong> Riavvia velocemente, eliminando ogni chiamata a <strong>fsck</strong> quando si sta riavvindo.</p>

<p><strong>-F</strong> Forza un controllo del filesystem al riavvio.</p>

<p><strong>-h</strong> Manda il segnale di Halt o spegne il computer quando <strong>shutdown</strong> è uscito. Questo dipende dal sistema hardware e dal BIOS.</p>

<p><strong>-H</strong> Ferma il sistema quando <strong>shutdown</strong> è uscito.</p>

<p><strong>-k</strong> Stampa i messaggi di warning, ma ferma lo shutdown attuale.</p>

<p><strong>-P</strong> Spegne il computer quando <strong>shutdown</strong> ha terminato.</p>

<p><strong>-r</strong> Riavvia il sistema quando <strong>shutdown</strong> ha terminato.</p>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="comando-telinit">Comando: telinit</h2>

<p><code>telinit [options] [runlevel]</code></p>

<p>Segnala a <strong>init</strong> di cambiare il runlevel di sistema. <strong>telinit</strong> è in SysV solamente un link a <strong>init</strong>, il padre di tutti i processi.</p>

<h3 id="opzioni-3">Opzioni</h3>

<p><strong>-t</strong> <em>seconds</em> Manda un SIGKILL dopo tot secondi (<em>seconds</em>) il SIGTERM. Di default sono 20.</p>

<h3 id="runlevels">Runlevels</h3>

<p>Qualche runlevel cambia da distribuzione a distribuzione, ma alcuni sono standard:</p>

<p><strong>0</strong> Manda il segnale di Halt</p>

<p><strong>1,s,S</strong> Modalità single-user</p>

<p><strong>6</strong> Riavvia il sistema</p>

<p><strong>a,b,c</strong> Processa solo le linee in <em>/etc/inittab/</em> che sono marcate con <em>a</em>, <em>b</em> o <em>c</em></p>

<p><strong>q, Q</strong> Rilegge <em>/etc/inittab</em></p>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="comando-uptime">Comando: uptime</h2>

<p><code>uptime [options]</code></p>

<p>Stampa il tempo corrente, quanto è stato attivo il sistema, il numero di utenti attualmente loggati (che può includere il proprio utente molte volte), e il carico medio del sistema.</p>

<h3 id="opzioni-4">Opzioni</h3>

<p><strong>-V</strong> Stampa la versione e esce.</p>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="sysv-punti-a-favore">SysV punti a favore</h2>

<ul>
  <li>Semplicità: Creare file di servizi è facile con SystemV init come è facile creare uno script di shell. Per abilitare o disabilitare un servizio in un particolare Runlevel c’è solo bisogno di aggiungere/rimuovere un link simbolico in un particolare insieme di directory</li>
  <li>Ordine di esecuzione dei servizi garantito: questo è possibile invocando gli init script puntati dai link simbolici in sequenza. L’ordine relativo in cui i servizi sono invocati da init dipende da un prefisso numerico nel nome. Servizi con numeri bassi sono avviati prima di servizi con numeri alti.</li>
</ul>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="sysv-svantaggi">SysV svantaggi</h2>
<ul>
  <li>Prestazioni non ottimali: quando fu introdotto il sistema di avvio init era appropriato, ma in moderni sistemi sembra “lento” nel senso che non sfrutta il parallelismo. Un “hack” utilizzata da molti Amministratori è di evitare la serializzazione mandando in background i servizi che si stanno aviando.</li>
  <li>Server Centric: quando i Computer venivano ancora chiamati Mainframe e i riavvii erano rari, l’approccio di SysV era perfetto. Ora buona parte degli utenti Linux Desktop o Mobile, che usano il dispositivo in mobilità, si aspettano di riavviare il computer anche molte volte durante la giornata.</li>
  <li>Assume inesistenza di device HotPlug: SysV assume non sia possibile aggiungere/rimuovere una risorsa hardware a runtime. Per questo è stato progettato per non reagire proattivamente.</li>
  <li>Ogni script esegue operazioni standard: Ad esempio, eseguono controlli iniziali, si assicurano non ci sia un’altra istanza attiva del servizio, controllano non ci siano cartello o file in utilizzo, rimuovo la cache vecchia, si assicurano che i demoni dipendenti siano in esecuzione e lanciano il servizio. La cosa più difficile e costosa è controllare se i demoni dipendenti sono avviati. La specifica LSB contiene degli helper che aiutano a svolgere queste operazioni, ma probabilmente dovrebbe essere il demone di Init a svolgerle.</li>
</ul>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="crash-course-upstart">Crash Course: Upstart</h2>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="job">Job</h2>
<p>Un job è un’unità di lavoro. In Upstart ne esistono di 3 tipi:</p>

<ul>
  <li>Task Job: è considerato un piccolo programma/script che può impiegare anche molto tempo a terminare, ma sappiamo che terminerà in un tempo fissato. Per esempio cancellare i file temporanei dall’hard disk oppure montare i file systems</li>
  <li>Service Job: è un processo che rimane avviato per sempre a meno che non venga fermato esplicitamente.</li>
  <li>Abstract Job: è job che non ha sezioni <em>script</em> ne sezioni <em>exec</em>. Job di questo tipo possono essere avviati e stoppati ma non hanno un PID association.</li>
</ul>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="job-states">Job States</h2>

<p><img src="upstart-states.png" alt="Upstart Job States" /></p>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="file-di-configurazione">File di Configurazione</h2>

<p>Ogni Job è definito in un file di configurazione in plain text. I file di configurazione hanno un nome simile a:</p>

<p><code>&lt;name&gt;.conf</code></p>

<h3 id="system-job">System Job</h3>

<p>Ogni Job di sistema è contenuto di default nella cartella:</p>

<p><code>/etc/init</code></p>

<h3 id="user-job">User Job</h3>

<p>Gli User JOB sono contenuti nella cartella:</p>

<p>‘$HOME/.init/’</p>

<p>Tuttavia non sono attivi di default.</p>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="job-example">Job Example</h2>

<pre><code># Un Job astratto può anche non contenere nessuna linea
# Per informazione inseriamo l'autore del JOB
author "foo"
# E qui sotto la descrizione del job stesso
description "questo è uno scaffold di job astratto"
# Questo è una JOB configuration completa
</code></pre>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="comando-initctl">Comando: initctl</h2>
<p><code>initctl [options] command</code></p>

<p><strong>initctl</strong> manda comandi al demone <strong>init</strong> Upstart. Usabile per monitorare Jobs e Eventi, chiamare Jobs direttamente o mandare eventi al sistema.</p>

<h3 id="opzioni-5">Opzioni</h3>
<p><strong>–no-wait</strong> Quando stiamo usando il comando <strong>start</strong>, <strong>stop</strong>, <strong>emit</strong>, esce immediatamente senza aspettare che la richiesta sia finita.</p>

<p><strong>–user</strong> Viene avviato in user-mode</p>

<h3 id="comandi">Comandi</h3>

<p><strong>list</strong></p>

<p><strong>emit</strong> Emette un evento al quale <strong>init</strong> può rispondere. Gli argomenti dell’evento possono essere passati in una lista di stringhe.</p>

<p><strong>list</strong> elenca tutti i Job conosciuti.</p>

<p><strong>start JOB</strong> avvia un Job con il nome JOB</p>

<p><strong>stop JOB</strong> ferma un Job con il nome JOB</p>

<p><strong>restart JOB</strong> riavvia un Job con il nome JOB</p>

<p><strong>reload JOB</strong> invia il segnale HUP al Job con il nome JOB</p>

<p><strong>status JOB</strong> visualizza lo stato del Job con il nome JOB</p>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="events">Events</h2>

<p>Anche degli eventi esistono 3 incarnazioni.</p>

<p>Per generare gli eventi viene usato initctl.</p>

<h3 id="segnali">Segnali</h3>

<p>I segnali sono eventi lanciati in maniera asincrona. Colui che annuncia questi eventi non aspetta che l’evento venga passato a tutti, ne aspetta la loro reazione.</p>

<p>Per inviare segnali bisogna invocare il comando:</p>

<p><code>initctl emit --no-wait SIGNAL</code></p>

<h3 id="metodi">Metodi</h3>

<p>Gli eventi metodo sono degli eventi sincroni che sono solitamente associati a dei task. Funzionano come metodi o chiamate a funzione.</p>

<p>Per emettere un evento metodo basta:</p>

<p><code>initctl emit METHOD</code></p>

<h3 id="hooks">Hooks</h3>

<p>Sono degli speciali segnali sincroni a cui non ci si aspetta che risponda nessuno con compiti “lunghi”. Ad esempio vengono usati per notificare tutti quando un Job si sta avviando; in questo caso manda un hook <strong>starting</strong> a tutto il sistema.</p>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="stanzas">Stanzas</h2>

<p>Le <em>stanzas</em> è il termine utilizzato per identificare i comandi di configurazione che sono accettati da un file di configurazione di JOB di Upstart.</p>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="elenco-stanzas">Elenco Stanzas</h2>

<p><img src="stanzas.png" alt="Stanza1" /></p>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="elenco-stanzas-1">Elenco Stanzas</h2>
<p><img src="stanzas2.png" alt="Stanza2" /></p>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="configuration-example">Configuration Example</h2>

<p>Data l’estrema semplicità dei file di configurazione upstart, posso mostrarvi la configurazione completa di cron senza andare in overflow.</p>

<pre><code># cron - regular background program processing daemon
#
# cron is a standard UNIX program that runs user-specified programs at
# periodic scheduled times

description     "regular background program processing daemon"

start on runlevel [2345]
stop on runlevel [!2345]

expect fork
respawn

exec cron
</code></pre>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="cron-4-sysv">Cron 4 SysV</h2>

<p><img src="sysv-cron.png" alt="cron" /></p>



  </section>

  <section class="slide">
    <!-- _S9SLIDE_ -->
<h2 id="addio-e-grazie-per-tutto-il-pesce">Addio e grazie per tutto il pesce</h2>

<p><img src="fish.png" alt="fish" /></p>

<!-- === end markdown block ===================================================== -->

  </section>



<!--
<footer class="slide">
	<h2>Thank you!</h2>
	<p>Closing remarks</p>
</footer>
-->

<script src="slideshow.js"></script>

<!-- Make sure the reference to -prefix-free works -->
<script src="prefixfree.min.js"></script>

<!-- Uncomment the plugins you need
<script src="plugins/css-edit.js"></script>
<script src="plugins/css-snippets.js"></script>
<script src="plugins/css-controls.js"></script>
-->
<script>var slideshow = new SlideShow();

</script>
	
</body>
</html>